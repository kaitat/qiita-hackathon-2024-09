// Code generated by sqlc-gen-ts-d1. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
//   sqlc-gen-ts-d1 v0.0.0-a@dfd4bfef4736967ca17cc23d18de20920fbd196998fe7aa191a205439d63fb58

import { D1Database, D1PreparedStatement, D1Result } from "@cloudflare/workers-types/experimental"

type Query<T> = {
  then(onFulfilled?: (value: T) => void, onRejected?: (reason?: any) => void): void;
  batch(): D1PreparedStatement;
}
const createUsersQuery = `-- name: createUsers :exec
INSERT INTO Users (id, name) VALUES (?1, ?2)`;

export type createUsersParams = {
  id: string;
  name: string;
};

export function createUsers(
  d1: D1Database,
  args: createUsersParams
): Query<D1Result> {
  const ps = d1
    .prepare(createUsersQuery)
    .bind(args.id, args.name);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getUserQuery = `-- name: getUser :one
SELECT id, name, image_url, created_at, updated_at FROM Users WHERE name = ?1`;

export type getUserParams = {
  name: string;
};

export type getUserRow = {
  id: string;
  name: string;
  imageUrl: string | null;
  createdAt: string;
  updatedAt: string;
};

type RawgetUserRow = {
  id: string;
  name: string;
  image_url: string | null;
  created_at: string;
  updated_at: string;
};

export function getUser(
  d1: D1Database,
  args: getUserParams
): Query<getUserRow | null> {
  const ps = d1
    .prepare(getUserQuery)
    .bind(args.name);
  return {
    then(onFulfilled?: (value: getUserRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawgetUserRow | null>()
        .then((raw: RawgetUserRow | null) => raw ? {
          id: raw.id,
          name: raw.name,
          imageUrl: raw.image_url,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getQuestionsQuery = `-- name: getQuestions :many
SELECT id, type, order_num, question, created_at, updated_at FROM Questions order by order_num asc`;

export type getQuestionsRow = {
  id: string;
  type: string;
  orderNum: number;
  question: string;
  createdAt: string;
  updatedAt: string;
};

type RawgetQuestionsRow = {
  id: string;
  type: string;
  order_num: number;
  question: string;
  created_at: string;
  updated_at: string;
};

export function getQuestions(
  d1: D1Database
): Query<D1Result<getQuestionsRow>> {
  const ps = d1
    .prepare(getQuestionsQuery);
  return {
    then(onFulfilled?: (value: D1Result<getQuestionsRow>) => void, onRejected?: (reason?: any) => void) {
      ps.all<RawgetQuestionsRow>()
        .then((r: D1Result<RawgetQuestionsRow>) => { return {
          ...r,
          results: r.results.map((raw: RawgetQuestionsRow) => { return {
            id: raw.id,
            type: raw.type,
            orderNum: raw.order_num,
            question: raw.question,
            createdAt: raw.created_at,
            updatedAt: raw.updated_at,
          }}),
        }})
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getQuestionByOrderNumQuery = `-- name: getQuestionByOrderNum :one
SELECT id, type, order_num, question, created_at, updated_at FROM Questions WHERE order_num = ?1`;

export type getQuestionByOrderNumParams = {
  orderNum: number;
};

export type getQuestionByOrderNumRow = {
  id: string;
  type: string;
  orderNum: number;
  question: string;
  createdAt: string;
  updatedAt: string;
};

type RawgetQuestionByOrderNumRow = {
  id: string;
  type: string;
  order_num: number;
  question: string;
  created_at: string;
  updated_at: string;
};

export function getQuestionByOrderNum(
  d1: D1Database,
  args: getQuestionByOrderNumParams
): Query<getQuestionByOrderNumRow | null> {
  const ps = d1
    .prepare(getQuestionByOrderNumQuery)
    .bind(args.orderNum);
  return {
    then(onFulfilled?: (value: getQuestionByOrderNumRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawgetQuestionByOrderNumRow | null>()
        .then((raw: RawgetQuestionByOrderNumRow | null) => raw ? {
          id: raw.id,
          type: raw.type,
          orderNum: raw.order_num,
          question: raw.question,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getRoomByIdQuery = `-- name: getRoomById :one
SELECT id, name, owner_id, member_id, created_at, updated_at FROM Rooms AS room WHERE id = ?1`;

export type getRoomByIdParams = {
  id: string;
};

export type getRoomByIdRow = {
  id: string;
  name: string;
  ownerId: string;
  memberId: string | null;
  createdAt: string;
  updatedAt: string;
};

type RawgetRoomByIdRow = {
  id: string;
  name: string;
  owner_id: string;
  member_id: string | null;
  created_at: string;
  updated_at: string;
};

export function getRoomById(
  d1: D1Database,
  args: getRoomByIdParams
): Query<getRoomByIdRow | null> {
  const ps = d1
    .prepare(getRoomByIdQuery)
    .bind(args.id);
  return {
    then(onFulfilled?: (value: getRoomByIdRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawgetRoomByIdRow | null>()
        .then((raw: RawgetRoomByIdRow | null) => raw ? {
          id: raw.id,
          name: raw.name,
          ownerId: raw.owner_id,
          memberId: raw.member_id,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getRoomsByOwnerIdQuery = `-- name: getRoomsByOwnerId :many
SELECT id, name, owner_id, member_id, created_at, updated_at FROM Rooms AS room WHERE owner_id = ?1`;

export type getRoomsByOwnerIdParams = {
  ownerId: string;
};

export type getRoomsByOwnerIdRow = {
  id: string;
  name: string;
  ownerId: string;
  memberId: string | null;
  createdAt: string;
  updatedAt: string;
};

type RawgetRoomsByOwnerIdRow = {
  id: string;
  name: string;
  owner_id: string;
  member_id: string | null;
  created_at: string;
  updated_at: string;
};

export function getRoomsByOwnerId(
  d1: D1Database,
  args: getRoomsByOwnerIdParams
): Query<D1Result<getRoomsByOwnerIdRow>> {
  const ps = d1
    .prepare(getRoomsByOwnerIdQuery)
    .bind(args.ownerId);
  return {
    then(onFulfilled?: (value: D1Result<getRoomsByOwnerIdRow>) => void, onRejected?: (reason?: any) => void) {
      ps.all<RawgetRoomsByOwnerIdRow>()
        .then((r: D1Result<RawgetRoomsByOwnerIdRow>) => { return {
          ...r,
          results: r.results.map((raw: RawgetRoomsByOwnerIdRow) => { return {
            id: raw.id,
            name: raw.name,
            ownerId: raw.owner_id,
            memberId: raw.member_id,
            createdAt: raw.created_at,
            updatedAt: raw.updated_at,
          }}),
        }})
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const createRoomQuery = `-- name: createRoom :exec
INSERT INTO Rooms (id, name, owner_id, member_id) VALUES (?1, ?2, ?3, ?4)`;

export type createRoomParams = {
  id: string;
  name: string;
  ownerId: string;
  memberId: string | null;
};

export function createRoom(
  d1: D1Database,
  args: createRoomParams
): Query<D1Result> {
  const ps = d1
    .prepare(createRoomQuery)
    .bind(args.id, args.name, args.ownerId, args.memberId);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getMessagesByRoomIdQuery = `-- name: getMessagesByRoomId :many
SELECT id, room_id, user_id, message, message_type, created_at, updated_at FROM Messages WHERE room_id = ?1 order by created_at asc`;

export type getMessagesByRoomIdParams = {
  roomId: string;
};

export type getMessagesByRoomIdRow = {
  id: string;
  roomId: string;
  userId: string;
  message: string;
  messageType: string;
  createdAt: string;
  updatedAt: string;
};

type RawgetMessagesByRoomIdRow = {
  id: string;
  room_id: string;
  user_id: string;
  message: string;
  message_type: string;
  created_at: string;
  updated_at: string;
};

export function getMessagesByRoomId(
  d1: D1Database,
  args: getMessagesByRoomIdParams
): Query<D1Result<getMessagesByRoomIdRow>> {
  const ps = d1
    .prepare(getMessagesByRoomIdQuery)
    .bind(args.roomId);
  return {
    then(onFulfilled?: (value: D1Result<getMessagesByRoomIdRow>) => void, onRejected?: (reason?: any) => void) {
      ps.all<RawgetMessagesByRoomIdRow>()
        .then((r: D1Result<RawgetMessagesByRoomIdRow>) => { return {
          ...r,
          results: r.results.map((raw: RawgetMessagesByRoomIdRow) => { return {
            id: raw.id,
            roomId: raw.room_id,
            userId: raw.user_id,
            message: raw.message,
            messageType: raw.message_type,
            createdAt: raw.created_at,
            updatedAt: raw.updated_at,
          }}),
        }})
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const createMessageQuery = `-- name: createMessage :exec
INSERT INTO Messages (id, room_id, user_id, message, message_type) VALUES (?1, ?2, ?3, ?4, ?5)`;

export type createMessageParams = {
  id: string;
  roomId: string;
  userId: string;
  message: string;
  messageType: string;
};

export function createMessage(
  d1: D1Database,
  args: createMessageParams
): Query<D1Result> {
  const ps = d1
    .prepare(createMessageQuery)
    .bind(args.id, args.roomId, args.userId, args.message, args.messageType);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const createAnswerQuery = `-- name: createAnswer :exec
INSERT INTO Answers (id, user_id, question_id, answer) VALUES (?1, ?2, ?3, ?4)`;

export type createAnswerParams = {
  id: string;
  userId: string;
  questionId: string;
  answer: string;
};

export function createAnswer(
  d1: D1Database,
  args: createAnswerParams
): Query<D1Result> {
  const ps = d1
    .prepare(createAnswerQuery)
    .bind(args.id, args.userId, args.questionId, args.answer);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getUsersQuery = `-- name: getUsers :many
SELECT id, name, image_url, created_at, updated_at FROM Users`;

export type getUsersRow = {
  id: string;
  name: string;
  imageUrl: string | null;
  createdAt: string;
  updatedAt: string;
};

type RawgetUsersRow = {
  id: string;
  name: string;
  image_url: string | null;
  created_at: string;
  updated_at: string;
};

export function getUsers(
  d1: D1Database
): Query<D1Result<getUsersRow>> {
  const ps = d1
    .prepare(getUsersQuery);
  return {
    then(onFulfilled?: (value: D1Result<getUsersRow>) => void, onRejected?: (reason?: any) => void) {
      ps.all<RawgetUsersRow>()
        .then((r: D1Result<RawgetUsersRow>) => { return {
          ...r,
          results: r.results.map((raw: RawgetUsersRow) => { return {
            id: raw.id,
            name: raw.name,
            imageUrl: raw.image_url,
            createdAt: raw.created_at,
            updatedAt: raw.updated_at,
          }}),
        }})
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

